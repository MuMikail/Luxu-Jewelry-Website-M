{"ast":null,"code":"/**\n * @license React\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\n\"production\" !== process.env.NODE_ENV && function () {\n  function computeFullKey(signature) {\n    if (null !== signature.fullKey) return signature.fullKey;\n    var fullKey = signature.ownKey;\n    try {\n      var hooks = signature.getCustomHooks();\n    } catch (err) {\n      return signature.forceReset = !0, signature.fullKey = fullKey;\n    }\n    for (var i = 0; i < hooks.length; i++) {\n      var hook = hooks[i];\n      if (\"function\" !== typeof hook) return signature.forceReset = !0, signature.fullKey = fullKey;\n      hook = allSignaturesByType.get(hook);\n      if (void 0 !== hook) {\n        var nestedHookKey = computeFullKey(hook);\n        hook.forceReset && (signature.forceReset = !0);\n        fullKey += \"\\n---\\n\" + nestedHookKey;\n      }\n    }\n    return signature.fullKey = fullKey;\n  }\n  function resolveFamily(type) {\n    return updatedFamiliesByType.get(type);\n  }\n  function cloneMap(map) {\n    var clone = new Map();\n    map.forEach(function (value, key) {\n      clone.set(key, value);\n    });\n    return clone;\n  }\n  function cloneSet(set) {\n    var clone = new Set();\n    set.forEach(function (value) {\n      clone.add(value);\n    });\n    return clone;\n  }\n  function getProperty(object, property) {\n    try {\n      return object[property];\n    } catch (err) {}\n  }\n  function register(type, id) {\n    if (!(null === type || \"function\" !== typeof type && \"object\" !== typeof type || allFamiliesByType.has(type))) {\n      var family = allFamiliesByID.get(id);\n      void 0 === family ? (family = {\n        current: type\n      }, allFamiliesByID.set(id, family)) : pendingUpdates.push([family, type]);\n      allFamiliesByType.set(type, family);\n      if (\"object\" === typeof type && null !== type) switch (getProperty(type, \"$$typeof\")) {\n        case REACT_FORWARD_REF_TYPE:\n          register(type.render, id + \"$render\");\n          break;\n        case REACT_MEMO_TYPE:\n          register(type.type, id + \"$type\");\n      }\n    }\n  }\n  function setSignature(type, key) {\n    var forceReset = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !1,\n      getCustomHooks = 3 < arguments.length ? arguments[3] : void 0;\n    allSignaturesByType.has(type) || allSignaturesByType.set(type, {\n      forceReset: forceReset,\n      ownKey: key,\n      fullKey: null,\n      getCustomHooks: getCustomHooks || function () {\n        return [];\n      }\n    });\n    if (\"object\" === typeof type && null !== type) switch (getProperty(type, \"$$typeof\")) {\n      case REACT_FORWARD_REF_TYPE:\n        setSignature(type.render, key, forceReset, getCustomHooks);\n        break;\n      case REACT_MEMO_TYPE:\n        setSignature(type.type, key, forceReset, getCustomHooks);\n    }\n  }\n  function collectCustomHooksForSignature(type) {\n    type = allSignaturesByType.get(type);\n    void 0 !== type && computeFullKey(type);\n  }\n  var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n    REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n    PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map,\n    allFamiliesByID = new Map(),\n    allFamiliesByType = new PossiblyWeakMap(),\n    allSignaturesByType = new PossiblyWeakMap(),\n    updatedFamiliesByType = new PossiblyWeakMap(),\n    pendingUpdates = [],\n    helpersByRendererID = new Map(),\n    helpersByRoot = new Map(),\n    mountedRoots = new Set(),\n    failedRoots = new Set(),\n    rootElements = \"function\" === typeof WeakMap ? new WeakMap() : null,\n    isPerformingRefresh = !1;\n  exports._getMountedRootCount = function () {\n    return mountedRoots.size;\n  };\n  exports.collectCustomHooksForSignature = collectCustomHooksForSignature;\n  exports.createSignatureFunctionForTransform = function () {\n    var savedType,\n      hasCustomHooks,\n      didCollectHooks = !1;\n    return function (type, key, forceReset, getCustomHooks) {\n      if (\"string\" === typeof key) return savedType || (savedType = type, hasCustomHooks = \"function\" === typeof getCustomHooks), null == type || \"function\" !== typeof type && \"object\" !== typeof type || setSignature(type, key, forceReset, getCustomHooks), type;\n      !didCollectHooks && hasCustomHooks && (didCollectHooks = !0, collectCustomHooksForSignature(savedType));\n    };\n  };\n  exports.getFamilyByID = function (id) {\n    return allFamiliesByID.get(id);\n  };\n  exports.getFamilyByType = function (type) {\n    return allFamiliesByType.get(type);\n  };\n  exports.hasUnrecoverableErrors = function () {\n    return !1;\n  };\n  exports.injectIntoGlobalHook = function (globalObject) {\n    var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n    if (void 0 === hook) {\n      var nextID = 0;\n      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n        renderers: new Map(),\n        supportsFiber: !0,\n        inject: function () {\n          return nextID++;\n        },\n        onScheduleFiberRoot: function () {},\n        onCommitFiberRoot: function () {},\n        onCommitFiberUnmount: function () {}\n      };\n    }\n    if (hook.isDisabled) console.warn(\"Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). Fast Refresh is not compatible with this shim and will be disabled.\");else {\n      var oldInject = hook.inject;\n      hook.inject = function (injected) {\n        var id = oldInject.apply(this, arguments);\n        \"function\" === typeof injected.scheduleRefresh && \"function\" === typeof injected.setRefreshHandler && helpersByRendererID.set(id, injected);\n        return id;\n      };\n      hook.renderers.forEach(function (injected, id) {\n        \"function\" === typeof injected.scheduleRefresh && \"function\" === typeof injected.setRefreshHandler && helpersByRendererID.set(id, injected);\n      });\n      var oldOnCommitFiberRoot = hook.onCommitFiberRoot,\n        oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};\n      hook.onScheduleFiberRoot = function (id, root, children) {\n        isPerformingRefresh || (failedRoots.delete(root), null !== rootElements && rootElements.set(root, children));\n        return oldOnScheduleFiberRoot.apply(this, arguments);\n      };\n      hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n        var helpers = helpersByRendererID.get(id);\n        if (void 0 !== helpers) {\n          helpersByRoot.set(root, helpers);\n          helpers = root.current;\n          var alternate = helpers.alternate;\n          null !== alternate ? (alternate = null != alternate.memoizedState && null != alternate.memoizedState.element && mountedRoots.has(root), helpers = null != helpers.memoizedState && null != helpers.memoizedState.element, !alternate && helpers ? (mountedRoots.add(root), failedRoots.delete(root)) : alternate && helpers || (alternate && !helpers ? (mountedRoots.delete(root), didError ? failedRoots.add(root) : helpersByRoot.delete(root)) : alternate || helpers || didError && failedRoots.add(root))) : mountedRoots.add(root);\n        }\n        return oldOnCommitFiberRoot.apply(this, arguments);\n      };\n    }\n  };\n  exports.isLikelyComponentType = function (type) {\n    switch (typeof type) {\n      case \"function\":\n        if (null != type.prototype) {\n          if (type.prototype.isReactComponent) return !0;\n          var ownNames = Object.getOwnPropertyNames(type.prototype);\n          if (1 < ownNames.length || \"constructor\" !== ownNames[0] || type.prototype.__proto__ !== Object.prototype) return !1;\n        }\n        type = type.name || type.displayName;\n        return \"string\" === typeof type && /^[A-Z]/.test(type);\n      case \"object\":\n        if (null != type) switch (getProperty(type, \"$$typeof\")) {\n          case REACT_FORWARD_REF_TYPE:\n          case REACT_MEMO_TYPE:\n            return !0;\n        }\n        return !1;\n      default:\n        return !1;\n    }\n  };\n  exports.performReactRefresh = function () {\n    if (0 === pendingUpdates.length || isPerformingRefresh) return null;\n    isPerformingRefresh = !0;\n    try {\n      var staleFamilies = new Set(),\n        updatedFamilies = new Set(),\n        updates = pendingUpdates;\n      pendingUpdates = [];\n      updates.forEach(function (_ref) {\n        var family = _ref[0];\n        _ref = _ref[1];\n        var prevType = family.current;\n        updatedFamiliesByType.set(prevType, family);\n        updatedFamiliesByType.set(_ref, family);\n        family.current = _ref;\n        prevType.prototype && prevType.prototype.isReactComponent || _ref.prototype && _ref.prototype.isReactComponent ? _ref = !1 : (prevType = allSignaturesByType.get(prevType), _ref = allSignaturesByType.get(_ref), _ref = void 0 === prevType && void 0 === _ref || void 0 !== prevType && void 0 !== _ref && computeFullKey(prevType) === computeFullKey(_ref) && !_ref.forceReset ? !0 : !1);\n        _ref ? updatedFamilies.add(family) : staleFamilies.add(family);\n      });\n      var update = {\n        updatedFamilies: updatedFamilies,\n        staleFamilies: staleFamilies\n      };\n      helpersByRendererID.forEach(function (helpers) {\n        helpers.setRefreshHandler(resolveFamily);\n      });\n      var didError = !1,\n        firstError = null,\n        failedRootsSnapshot = cloneSet(failedRoots),\n        mountedRootsSnapshot = cloneSet(mountedRoots),\n        helpersByRootSnapshot = cloneMap(helpersByRoot);\n      failedRootsSnapshot.forEach(function (root) {\n        var helpers = helpersByRootSnapshot.get(root);\n        if (void 0 === helpers) throw Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n        failedRoots.has(root);\n        if (null !== rootElements && rootElements.has(root)) {\n          var element = rootElements.get(root);\n          try {\n            helpers.scheduleRoot(root, element);\n          } catch (err) {\n            didError || (didError = !0, firstError = err);\n          }\n        }\n      });\n      mountedRootsSnapshot.forEach(function (root) {\n        var helpers = helpersByRootSnapshot.get(root);\n        if (void 0 === helpers) throw Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n        mountedRoots.has(root);\n        try {\n          helpers.scheduleRefresh(root, update);\n        } catch (err) {\n          didError || (didError = !0, firstError = err);\n        }\n      });\n      if (didError) throw firstError;\n      return update;\n    } finally {\n      isPerformingRefresh = !1;\n    }\n  };\n  exports.register = register;\n  exports.setSignature = setSignature;\n}();","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}